
package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:
	Logger log = Logger.getLogger(getClass());

	public void report_fatal_error(String message, Object info) throws java.lang.Exception {
		done_parsing(); report_error(message, info); }

	public void syntax_error(Symbol curr_token) {
		report_error("\nSintaksna greska", curr_token); }

	public void unrecovered_syntax_error(Symbol curr_token) throws java.lang.Exception {
		report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", curr_token); }

	public void report_error(String message, Object info) {
		StringBuilder msg = new StringBuilder(message);
		if (info instanceof Symbol)
			msg.append(" na liniji ").append(((Symbol)info).left);
		log.error(msg.toString());
	}
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal PROG, LBRACE, RBRACE, SEMI, LPAREN, RPAREN, EQUAL, RETURN;
terminal DOUBLEMINUS, DOUBLECOLON, READ, NEW, COMMA, DOUBLEPLUS;
terminal VOID, PRINT;
terminal LBRACKET, CONST, RBRACKET, NAMESPACE;
terminal Integer NUMBER;
terminal String IDENT, CHARACTER, BOOLEAN;
terminal String PLUS, MINUS, MUL, DIV, PER;

nonterminal VarDeclList VarDeclList;
nonterminal MethodDeclList MethodDeclList;
nonterminal VarDecl VarDecl;
nonterminal StatementList StatementList;
nonterminal Statement Statement;
nonterminal DeclList DeclList;
nonterminal ConstDeclList ConstDeclList;
nonterminal ProgNameDeclList ProgNameDeclList;
nonterminal rs.etf.pp1.symboltable.concepts.Obj NamespaceDecl, NamespaceName;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Program, SimpleDesignator;
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodDecl, MethodName;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ArrayDesignator;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Addop, Mulop, Identifier;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Term, Factor, Expr;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Initializator, ConstIdentifier;


Program ::= (Prog) PROG ProgName:p ProgNameDeclList:P1 LBRACE MethodDeclList:M2 RBRACE {: RESULT=new Prog(p, P1, M2); RESULT.setLine(pleft); :};

ProgName ::= (ProgName) IDENT:progName {: RESULT=new ProgName(progName); RESULT.setLine(progNameleft); :};

ProgNameDeclList ::= ProgNameDeclList:P1 NamespaceDecl:N2 {: RESULT=new ProgNameDeclListDerived1(P1, N2); RESULT.setLine(P1left); :}
					| ProgNameDeclList:P1 VarDecl:V2 {: RESULT=new ProgNameDeclListDerived2(P1, V2); RESULT.setLine(P1left); :}
					| {: RESULT=new ProgNameDeclListDerived3(); :} /* epsilon */;

NamespaceDecl ::= NAMESPACE NamespaceName:N1 LBRACE VarDeclList:V2 LBRACE RBRACE RBRACE {: RESULT=new NamespaceDeclDerived1(N1, V2); RESULT.setLine(N1left); :};

NamespaceName ::= (NamespName) IDENT:i {: RESULT=new NamespName(i); RESULT.setLine(ileft); :};

VarDeclList ::= VarDeclList:V1 VarDecl:V2 {: RESULT=new VarDeclListDerived1(V1, V2); RESULT.setLine(V1left); :}
			| {: RESULT=new VarDeclListDerived2(); :} /* epsilon */;

VarDecl ::= (DeclListType) Type:varType DeclList:D1 SEMI {: RESULT=new DeclListType(varType, D1); RESULT.setLine(varTypeleft); :}
		| (ConstDeclListType) CONST Type:varType ConstDeclList:C1 SEMI {: RESULT=new ConstDeclListType(varType, C1); RESULT.setLine(varTypeleft); :}
		| error SEMI:l
		{:
			parser.report_error(
				"Izvrsen oporavak do ; u deklaraciji promenljivih na liniji "
				+ lleft, null
			);
		:} {: RESULT=new VarDeclDerived1(); :};

DeclList ::= Identifier:I1 COMMA DeclList:D2 {: RESULT=new DeclListDerived1(I1, D2); RESULT.setLine(I1left); :}
			| Identifier:I1 {: RESULT=new DeclListDerived2(I1); RESULT.setLine(I1left); :};

Identifier ::= (SIdentDecl) IDENT:I1 {: RESULT=new SIdentDecl(I1); RESULT.setLine(I1left); :}
			| (AIdentDecl) IDENT:I1 LBRACKET RBRACKET {: RESULT=new AIdentDecl(I1); RESULT.setLine(I1left); :}
			| (IIdentDecl) IDENT:I1 EQUAL Initializator:I2 {: RESULT=new IIdentDecl(I1, I2); RESULT.setLine(I1left); :}
			| error
			{:
				parser.report_error(
					"Izvrsen oporavak do ,(|;) u deklaraciji promenljivih",
					null
				);
			:} {: RESULT=new IdentifierDerived1(); :};

ConstDeclList ::= ConstIdentifier:C1 COMMA ConstDeclList:C2 {: RESULT=new ConstDeclListDerived1(C1, C2); RESULT.setLine(C1left); :}
				| ConstIdentifier:C1 {: RESULT=new ConstDeclListDerived2(C1); RESULT.setLine(C1left); :};

ConstIdentifier ::= (CIdentDecl) IDENT:I1 EQUAL Initializator:I2 {: RESULT=new CIdentDecl(I1, I2); RESULT.setLine(I1left); :}
				| error
				{:
					parser.report_error(
						"Izvrsen oporavak do ,(|;) u deklaraciji promenljivih",
						null
					);
				:} {: RESULT=new ConstIdentifierDerived1(); :};
			
Initializator ::= (NInit) NUMBER:N1 {: RESULT=new NInit(N1); RESULT.setLine(N1left); :} | (CInit) CHARACTER:C1 {: RESULT=new CInit(C1); RESULT.setLine(C1left); :} | (BInit) BOOLEAN:B1 {: RESULT=new BInit(B1); RESULT.setLine(B1left); :};

Type ::= (TypeAccess) IDENT:typeName {: RESULT=new TypeAccess(typeName); RESULT.setLine(typeNameleft); :};

MethodDeclList ::= MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclListDerived1(M1, M2); RESULT.setLine(M1left); :}
				| {: RESULT=new MethodDeclListDerived2(); :} /* epsilon */;

MethodDecl ::= (MethodDeclaration) VOID MethodName:M1 LPAREN RPAREN VarDeclList:V2 LBRACE StatementList:S3 RBRACE {: RESULT=new MethodDeclaration(M1, V2, S3); RESULT.setLine(M1left); :};

MethodName ::= (MethName) IDENT:I1 {: RESULT=new MethName(I1); RESULT.setLine(I1left); :};

StatementList ::= StatementList:S1 Statement:S2 {: RESULT=new StatementListDerived1(S1, S2); RESULT.setLine(S1left); :}
				| {: RESULT=new StatementListDerived2(); :} /* epsilon */;

Statement ::= (SDesignAsign) SimpleDesignator:S1 EQUAL Expr:e SEMI {: RESULT=new SDesignAsign(S1, e); RESULT.setLine(S1left); :}
			| (ADesignAsign) ArrayDesignator:A1 EQUAL Expr:e SEMI {: RESULT=new ADesignAsign(A1, e); RESULT.setLine(A1left); :}
			| (ArrayAlloc) SimpleDesignator:S1 EQUAL NEW Type:T2 LBRACKET Expr:E3 RBRACKET SEMI {: RESULT=new ArrayAlloc(S1, T2, E3); RESULT.setLine(S1left); :}
			| error SEMI:l
			{:
				parser.report_error(
					"Izvrsen oporavak do ; na liniji "
					+ lleft, null
				);
			:} {: RESULT=new StatementDerived1(); :}
			| (SDesignInc) SimpleDesignator:S1 DOUBLEPLUS SEMI {: RESULT=new SDesignInc(S1); RESULT.setLine(S1left); :}
			| (ADesignInc) ArrayDesignator:A1 DOUBLEPLUS SEMI {: RESULT=new ADesignInc(A1); RESULT.setLine(A1left); :}
			| (SDesignDec) SimpleDesignator:S1 DOUBLEMINUS SEMI {: RESULT=new SDesignDec(S1); RESULT.setLine(S1left); :}
			| (ADesignDec) ArrayDesignator:A1 DOUBLEMINUS SEMI {: RESULT=new ADesignDec(A1); RESULT.setLine(A1left); :}
			| READ LPAREN SimpleDesignator:S1 RPAREN SEMI {: RESULT=new StatementDerived2(S1); RESULT.setLine(S1left); :}
			| READ LPAREN ArrayDesignator:A1 RPAREN SEMI {: RESULT=new StatementDerived3(A1); RESULT.setLine(A1left); :}
			| (PrintStmt) PRINT LPAREN Expr:E1 RPAREN SEMI {: RESULT=new PrintStmt(E1); RESULT.setLine(E1left); :}
			| (PrintOnWith) PRINT LPAREN Expr:E1 COMMA NUMBER:N2 RPAREN SEMI {: RESULT=new PrintOnWith(E1, N2); RESULT.setLine(E1left); :}
			| RETURN SEMI {: RESULT=new StatementDerived4(); :};

Expr ::= (AddExpr) Expr:E1 Addop:A2 Term:T3 {: RESULT=new AddExpr(E1, A2, T3); RESULT.setLine(E1left); :}
		| (NegExpr) MINUS:M1 Term:T2 {: RESULT=new NegExpr(M1, T2); RESULT.setLine(M1left); :}
		| (TermExpr) Term:T1 {: RESULT=new TermExpr(T1); RESULT.setLine(T1left); :};

Term ::= (MulTerm) Term:t Mulop:M1 Factor:te {: RESULT=new MulTerm(t, M1, te); RESULT.setLine(tleft); :}
		| (FactorTerm) Factor:t {: RESULT=new FactorTerm(t); RESULT.setLine(tleft); :};

Factor ::= (NumberConst) NUMBER:N1 {: RESULT=new NumberConst(N1); RESULT.setLine(N1left); :}
		| (CharacterConst) CHARACTER:C1 {: RESULT=new CharacterConst(C1); RESULT.setLine(C1left); :}
		| (BooleanConst) BOOLEAN:B1 {: RESULT=new BooleanConst(B1); RESULT.setLine(B1left); :}
		| (ParenExpr) LPAREN Expr:E1 RPAREN {: RESULT=new ParenExpr(E1); RESULT.setLine(E1left); :}
		| (SFactorDesignator) SimpleDesignator:d {: RESULT=new SFactorDesignator(d); RESULT.setLine(dleft); :}
		| (AFactorDesignator) ArrayDesignator:d {: RESULT=new AFactorDesignator(d); RESULT.setLine(dleft); :};

SimpleDesignator ::= (Ident) IDENT:name {: RESULT=new Ident(name); RESULT.setLine(nameleft); :}
					| (NsIdent) IDENT:namesp DOUBLECOLON IDENT:name {: RESULT=new NsIdent(namesp, name); RESULT.setLine(namespleft); :};

ArrayDesignator ::= (ArrIdent) IDENT:name LBRACKET Expr:E1 RBRACKET {: RESULT=new ArrIdent(name, E1); RESULT.setLine(nameleft); :}
				| (NsArrIdent) IDENT:namesp DOUBLECOLON IDENT:name LBRACKET Expr:E1 RBRACKET {: RESULT=new NsArrIdent(namesp, name, E1); RESULT.setLine(namespleft); :};

Mulop ::= (Mul) MUL:M1 {: RESULT=new Mul(M1); RESULT.setLine(M1left); :} | (Div) DIV:D1 {: RESULT=new Div(D1); RESULT.setLine(D1left); :} | (Per) PER:P1 {: RESULT=new Per(P1); RESULT.setLine(P1left); :};

Addop ::= (Plus) PLUS:P1 {: RESULT=new Plus(P1); RESULT.setLine(P1left); :} | (Minus) MINUS:M1 {: RESULT=new Minus(M1); RESULT.setLine(M1left); :};